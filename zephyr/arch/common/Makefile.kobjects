GEN_KOBJ_LIST := $(srctree)/scripts/gen_kobject_list.py
PROCESS_GPERF := $(srctree)/scripts/process_gperf.py
OBJ_LIST := kobject_hash.gperf
OUTPUT_SRC_PRE := kobject_hash_preprocessed.c
OUTPUT_SRC := kobject_hash.c
OUTPUT_OBJ := kobject_hash.o
OUTPUT_OBJ_RENAMED := kobject_hash_renamed.o

SCRIPT_EXTRA_ARGS :=

ifeq ($(KBUILD_VERBOSE),1)
SCRIPT_EXTRA_ARGS += --verbose
endif

# Scan the kernel binary's DWARF information to produce a table of
# kernel objects which we will pass to gperf
quiet_cmd_gen_kobj_list = KOBJ    $@
      cmd_gen_kobj_list = $(GEN_KOBJ_LIST) --kernel $< --output $@ \
				$(SCRIPT_EXTRA_ARGS)

$(OBJ_LIST): $(PREBUILT_KERNEL) $(GEN_KOBJ_LIST)
	$(call cmd,gen_kobj_list)

# Generate C code which implements a perfect hashtable based on our
# table of kernel objects
quiet_cmd_gperf = GPERF   $@
      cmd_gperf = gperf --output-file=$@ $<

$(OUTPUT_SRC_PRE): $(OBJ_LIST)
	$(call cmd,gperf)

# For our purposes, the code/data generated by gperf is not optimal.
# This script adjusts the generated .c file to greatly reduce the amount
# of code/data generated since we know we are always working with
# pointer values
quiet_cmd_process_gperf = PROCESS $@
      cmd_process_gperf = $(PROCESS_GPERF) -i $< -o $@ $(SCRIPT_EXTRA_ARGS)

$(OUTPUT_SRC): $(OUTPUT_SRC_PRE) $(PROCESS_GPERF)
	$(call cmd,process_gperf)

# We need precise control of where generated text/data ends up in the final
# kernel image. Disable function/data sections and use objcopy to move
# generated data into special section names
$(OUTPUT_OBJ): KBUILD_CFLAGS += -fno-function-sections -fno-data-sections

quiet_cmd_kobject_objcopy = OBJCOPY $@
      cmd_kobject_objcopy = $(OBJCOPY) \
			    --rename-section .data=.kobject_data.data \
			    --rename-section .rodata=.kobject_data.rodata \
			    --rename-section .text=.kobject_data.text \
			    $< $@

$(OUTPUT_OBJ_RENAMED): $(OUTPUT_OBJ)
	$(call cmd,kobject_objcopy)

GENERATED_KERNEL_OBJECT_FILES += $(OUTPUT_OBJ_RENAMED)
